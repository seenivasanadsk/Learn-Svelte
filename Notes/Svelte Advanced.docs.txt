Advanced reactivity
  * Raw state ($state.raw()) only reactive when value reassign. not works on objects and array updates
  * In svelte class properties also reactive
  * Svlete also gives reactivity in some differant ways like (MediaQuery, SvelteDate, SvelteMap, SvelteSet, SvelteURL, SvelteURLSearchParams, createSubscriber)
  * Svelte offers predefine Store
    * we should assign use writable instead of $state in stores and the writable is impreted from 'svelte/store'
    * and in compoents we should use it with prefix $

Reusing Content
  * Snippet is minimal html code that reusable rendering, Syntex: {#snippet monkey(emoji, description)}...{/snippet}
  * we can aslo pass custom parameter to it
  * And use it by Syntex: {@render monkey('ðŸ™ˆ', 'see no evil')}
  * We can also pass snippet into children compoents via props and render in children
  * If we declare a snippets inside a Components tag its directly passed as porps automatically, only outside snippet should pass manually
  * if the code without snippet which is a normal children without snipets considerd as "children" in child compoents

Motion
  * The swelte motion is used some transition effect, currletly we have two option tween and spring
  * Tween - This is leaner motion
    * Syntex: let obj = new Tween(0)
      * here we pass initial value into the Tween
      * and we have two key obj.current and obj.target, the obj.current is incremanet in a certain time if we set a target so we can make transition
  * Spring - This is Spring based motion like a real Spring
    * Syntex: let obj = new Spring(0, { stiffness: 0.25, damping: 0.25 })
      * here we pass initial value in first arguemnt and second options like stiffness and damping for spring behaviours
      * and same as we can access via obj.current and modify by obj.target

Advanced Bindings
  * We can also bind contenteditable html with bind:innerHTML & bind:innerText
  * We can also directly assin a value to the looped variable {#each todos as todo}...{/each} here we can directly put todo.value
  * We can also bind some special element attribute like bind:pause
  * We can also bind element widh and hight to the variable (clientWidh, clientHeight, offsetWidth, offsetHeight), these are readonly
  * We can also bind the Dom element directly by bind:this
  * We can make two way binding by modify props in children componets by in children syntex:(let { test = $bindable() } = $props();) and parent syntex:(<Test bind:test/>)
  * We can also bind a svelte compoents by bind:this

Advanced transition
  [IGNORED] - because its not working when learned

Context API
  * we can set and get a value which is should be object if context shouold be reactive, via setContext, and getContext

Special element
  * <svelte:window> - it should not contains children and refers a window object, we can define global events here
    * we can bind these follows: innerWidth, innerHeight, outerWidth, outerHeight, scrollX, scrollY, online
  * <svelte:document> - it should not children same as windows, it refers document object
  * <svelte:body> - it should not children same as windows, it refers document body
  * <svelte:head> - we can inject stylesheet in the head tag by defineing inside its children and it donest has any attirbute
  * <svelte:element this="input"> - we can render different element by change this attraibute by tag name dynamically
  * <svelte:boundary> - this error boundary inside we can put children with {#snippet failed(error, reset)} snipets to show when error occured
    * and we can also use onerror on these element to handle programmatically

<script module>
  * if we use <script module> this is rune once whenever we imported and all its code is share across its multiple instnace
  * if we anything export inside the <script module> file then its imporatable whenever we want
